---
title: 'Work in Progress - Do not use!'
output: html_document
---

```{r libraries, echo = F, message = F, warning = F, results='hide'}
library(lubridate, warn.conflicts = F)
library(plotly, warn.conflicts = F)
library(ggplot2, warn.conflicts = F)
library(magrittr, warn.conflicts = F)
library(dplyr, warn.conflicts = F)
Sys.setlocale('LC_TIME', 'C')
```

```{r data, echo = F}
johns_hopkins <- read.csv("data/clean/data_world_jh.csv")
#germany <- read.csv("data/clean/data_ger_bundl.csv")
```

```{r plots, echo = F, cache = F, message = F}

R.H <- function(
    new.cases, # I
    profile, # w
    window = 1, # H
    delay = 0, # Delta
    conf.level = 0.95, # 1-alpha
    pad.zeros = FALSE
) {
    # pad zeros if desired
    if(pad.zeros) new.cases <- c(rep(0, length(profile) - 1), new.cases)

    # compute convolutions over h, tau and both, respectively
    sum.h.I <- as.numeric(stats::filter(new.cases, rep(1, window),
        method = "convolution", sides = 1))
    sum.tau.wI <- as.numeric(stats::filter(new.cases, c(0, profile),
        method = "convolution", sides = 1))
    sum.htau.wI <- as.numeric(stats::filter(sum.tau.wI, rep(1, window),
        method = "convolution", sides = 1))

    # estimators
    RH <- sum.h.I / sum.htau.wI

    # standard errors
    RH.se <- sqrt(RH / sum.htau.wI)

    # shift by delay
    RH <- c(RH, rep(NA, delay))[(1:length(RH)) + delay]
    RH.se <- c(RH.se, rep(NA, delay))[(1:length(RH.se)) + delay]

    # standard normal qunatile
    q <- qnorm(1 - (1-conf.level) / 2)

    # return data.frame with as many rows as new.cases
    ret <- data.frame(R.H = RH, R.H.se = RH.se,
        R.H.lower = RH - q * RH.se, R.H.upper = RH + q * RH.se)
    if(pad.zeros) ret[-(1:(length(profile)-1)),] else ret
}

# geometric decay:
#infectivity <- c(0, .5, (1 - 1/6)^(0:21))
#names(infectivity) <- seq_along(infectivity)
#infectivity <- infectivity / sum(infectivity)
# more realistic:
infectivity <- c((0:3)/3, 1, (5:0)/5)
names(infectivity) <- seq_along(infectivity)
infectivity <- infectivity / sum(infectivity)


width <- 2
report.delay <- 7
alpha <- 0.05

make_plot <- function(country_name) {
    country <- johns_hopkins %>%
        filter(reg0.name == country_name) %>%
        mutate(date = ymd(date))

    estimates <- cbind(country, R.H(
            new.cases = country$new.cases,
            profile = infectivity,
            window = width,
            delay = report.delay,
            conf.level = 1-alpha,
            pad.zeros = TRUE
            ))

    # estimate and subtract effect of weekday on a log-scale
    # assuming constant proportion of under-/overreporting per weekday
    estimates$logRH <- log(estimates$R.H)
    estimates$logRH[is.infinite(estimates$logRH)] <- NA
    estimates$wday <- factor(wday(estimates$date))
    lm.wday <- lm(logRH ~ wday, estimates, weights = R.H / R.H.se)
    lm.inter <- lm(logRH ~ 1, estimates, weights = R.H / R.H.se)
    estimates$RH.wday <- exp(
        estimates$logRH - predict(lm.wday, newdata = estimates) + predict(lm.inter, newdata = estimates)
    )

    estimates <- estimates %>%
        filter(!is.na(R.H), !is.na(R.H.lower), !is.na(R.H.upper)) %>%
        filter(tot.cases > 30)

    first_monday <- ymd("2020-01-06")
    p <- ggplot(estimates, aes(x = date, y = R.H)) +
        geom_line() +
        # bug in ggplotly, so we have to split our lines into two pieces
        # see https://github.com/tidyverse/ggplot2/issues/2006
        geom_ribbon(aes(ymin = R.H.lower, ymax = R.H.upper), alpha = 0.2) +
        #theme_bw() +
        scale_y_log10(breaks = c(1:5, 7, 10)) +
        scale_x_date(breaks = seq(first_monday, today(), by = "1 week"),
            minor_breaks = "1 day",
            date_labels = "%d/%m") +
        # explicit ylim can lead to NaN
        #xlim(estimates$date[1], today()) +
        geom_hline(
            yintercept = c(1.0), # R_0 = 2.5
            color = "red",
            linetype = "dotted",
            alpha = .5
            ) +
        #geom_vline(
        #    xintercept = as.numeric(
        #        seq(ymd("2020-02-03"), by = "1 week", length.out = 100) - .5
        #    ),
        #    linetype = "twodash",
        #    alpha = 0.6,
        #    color = "blue"
        #) +
        labs(title = paste0("Reproduction number for ", country_name, " over time"),
            x = "date",
            y = "R(t)"
            ) 
        

    ggplotly(p)
}

```

## {.tabset .tabset-fade}

Explanation of what we do.

<!--
See https://github.com/rstudio/flexdashboard/issues/80#issuecomment-247139450
on generating tabs in rmarkdown automatically
-->
```{r, echo = F, warning = F, message = F}

maxday <- max(johns_hopkins$day)
df <- subset(johns_hopkins, day == maxday, select = c(reg0.name, tot.cases))
df <- df[rev(order(df$tot.cases)),]
countries <- df$reg0.name[1:21]

#countries <- c("Germany", "Italy", "Spain", "France", "Switzerland", "Netherlands", "Austria", "United Kingdom", "Korea, South", "US")
names(countries) <- countries

plots <- lapply(countries, make_plot)

out <- lapply(seq_along(plots), function(i) {

  a1 <- knitr::knit_expand(text = sprintf("### %s\n", countries[i])) # tab header, auto extracts names of `hcs`
  a2 <- knitr::knit_expand(text = "\n```{r, echo = F, fig.width = 10}") # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nplots[[%d]]", i)) # extract graphs by "writing" out `hcs[[1]]`, `hcs[[2]]` etc. to be rendered later
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

##
