---
title: 'Work in Progress - Do not use!'
output: html_document
---

```{r libraries, echo = F, message = F, warning = F, results='hide'}
library(lubridate, warn.conflicts = F)
library(plotly, warn.conflicts = F)
library(ggplot2, warn.conflicts = F)
library(magrittr, warn.conflicts = F)
library(dplyr, warn.conflicts = F)
Sys.setlocale('LC_TIME', 'C')
```

```{r data, echo = F}
johns_hopkins <- read.csv("data/clean/data_world_jh.csv")
#germany <- read.csv("data/clean/data_ger_bundl.csv")
```

```{r plots, echo = F, cache = F, message = F}

R.H <- function(
    new.cases, # I
    profile, # w
    window = 1, # H
    delay = 0, # Delta
    conf.level = 0.95, # 1-alpha
    pad.zeros = FALSE
) {
    # pad zeros if desired
    if(pad.zeros) new.cases <- c(rep(0, length(profile) - 1), new.cases)

    # compute convolutions over h, tau and both, respectively
    sum.h.I <- as.numeric(stats::filter(new.cases, rep(1, window),
        method = "convolution", sides = 1))
    sum.tau.wI <- as.numeric(stats::filter(new.cases, c(0, profile),
        method = "convolution", sides = 1))
    sum.htau.wI <- as.numeric(stats::filter(sum.tau.wI, rep(1, window),
        method = "convolution", sides = 1))

    # estimators
    RH <- sum.h.I / sum.htau.wI

    # standard errors
    RH.se <- sqrt(RH / sum.htau.wI)

    # shift by delay
    RH <- c(RH, rep(NA, delay))[(1:length(RH)) + delay]
    RH.se <- c(RH.se, rep(NA, delay))[(1:length(RH.se)) + delay]

    # standard normal qunatile
    q <- qnorm(1 - (1-conf.level) / 2)

    # return data.frame with as many rows as new.cases
    ret <- data.frame(R.H = RH, R.H.se = RH.se,
        R.H.lower = RH - q * RH.se, R.H.upper = RH + q * RH.se)
    if(pad.zeros) ret[-(1:(length(profile)-1)),] else ret
}

# geometric decay:
#infectivity <- c(0, .5, (1 - 1/6)^(0:21))
#names(infectivity) <- seq_along(infectivity)
#infectivity <- infectivity / sum(infectivity)
# more realistic:
infectivity <- c((0:3)/3, 1, (5:0)/5)
names(infectivity) <- seq_along(infectivity)
infectivity <- infectivity / sum(infectivity)


width <- 2
report.delay <- 7
alpha <- 0.05

make_plot <- function(country_name) {
    country <- johns_hopkins %>%
        filter(reg0.name == country_name) %>%
        mutate(date = ymd(date))

    estimates <- cbind(country, R.H(
            new.cases = country$new.cases,
            profile = infectivity,
            window = width,
            delay = report.delay,
            conf.level = 1-alpha,
            pad.zeros = TRUE
            ))

    # estimate and subtract effect of weekday on a log-scale
    # assuming constant proportion of under-/overreporting per weekday
    estimates$logRH <- log(estimates$R.H)
    estimates$logRH[is.infinite(estimates$logRH)] <- NA
    estimates$wday <- factor(wday(estimates$date))
    lm.wday <- lm(logRH ~ wday, estimates, weights = R.H / R.H.se)
    lm.inter <- lm(logRH ~ 1, estimates, weights = R.H / R.H.se)
    estimates$RH.wday <- exp(
        estimates$logRH - predict(lm.wday, newdata = estimates) + predict(lm.inter, newdata = estimates)
    )

    estimates <- estimates %>%
        filter(tot.cases > 30)

    first_monday <- ymd("2020-01-06")
    plot_ly(estimates, x= ~date, y= ~R.H) %>%
        add_bars(y = ~new.cases, yaxis = "y2", opacity = .3, name = "new cases") %>%
        add_lines(name = "R(t)") %>%
        add_ribbons(ymin = ~R.H.lower, ymax = ~R.H.upper, opacity = .5, name = "confidence sets") %>%
        layout(
            shapes = list(
                list(
                    type = "line",
                    x0 = 0, x1 = 1,
                    xref = "paper",
                    y0 = 1, y1 = 1,
                    line = list(color = "red", dash = "dot")
                    )#,
#                list(
#                    type = "line",
#                    x0 = 0, x1 = 1,
#                    xref = "paper",
#                    y0 = 2.4, y1 = 2.4,
#                    line = list(color = "red", dash = "dot")
#                )
                ),
            yaxis = list(
                type = "log",
                title = "R(t)",
                tickmode = "array",
                tickvals = 1:10,
                range = log(c(min(c(0.3, estimates$R.H.lower), na.rm = TRUE), 10), base = 10)
                ),
            colorway = c("blue", "black", "grey"),
            yaxis2 = list(
                overlaying = "y",
                side = "right",
                title = "new cases"
                ),
            xaxis =  list(
                ticks = "outside",
                tickvals = seq(first_monday, today(), by = "1 day"),
                showline = TRUE,
                showgrid = TRUE,
                type = "date",
                tickformat = "%d-%m"
            )
        )
}

```

## {.tabset .tabset-fade}

Created by [AG Stochastik](https://www.tu-ilmenau.de/stochastik/), [Technische Universit√§t Ilmenau](https://www.tu-ilmenau.de/).

<!--
See https://github.com/rstudio/flexdashboard/issues/80#issuecomment-247139450
on generating tabs in rmarkdown automatically
-->
```{r, echo = F, warning = F, message = F}

maxday <- max(johns_hopkins$day)
df <- subset(johns_hopkins, day == maxday, select = c(reg0.name, tot.cases))
df <- df[rev(order(df$tot.cases)),]
countries <- df$reg0.name[1:21]

#countries <- c("Germany", "Italy", "Spain", "France", "Switzerland", "Netherlands", "Austria", "United Kingdom", "Korea, South", "US")
names(countries) <- countries

plots <- lapply(countries, make_plot)

out <- lapply(seq_along(plots), function(i) {

  a1 <- knitr::knit_expand(text = sprintf("### %s\n", countries[i])) # tab header, auto extracts names of `hcs`
  a2 <- knitr::knit_expand(text = "\n```{r, echo = F, fig.width = 10}") # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nplots[[%d]]", i)) # extract graphs by "writing" out `hcs[[1]]`, `hcs[[2]]` etc. to be rendered later
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

Explanations (see the [Technical Report]() for details):
- We estimate the **reproduction rate** $R(t)$ at day $t$, i.e. the average number of people someone infected at time $t$ would infect if conditions remained the same.
- The estimator has been taken from [(Fraser 2007)][1] with (asymptotic) 95% confidence intervals derived using the delta method.
- Estimates and confidence intervals are shown in black, corresponding to the left axis (on a log-scale).
- The **critical value** for the reproduction number is $1$, shown as a red horizontal line: a value larger than one results in an exponential increase of infections, a value smaller than one in a decrease.
- The analysis is based on *newly reported cases* per day, shown as blue bars corresponding to the right axis (on a linear scale).
- We use the data provided by [Johns Hopkins University](https://github.com/CSSEGISandData/COVID-19), updating our graphics daily.
- Note that cases are reported much later than the corresponding day of infection, namely after incubation time and some more days necessary for testing and reporting the case to the authorities. For simplicity we assume that cases are reported 7 days after infection.
- In a population where no countermeasures have been put into place, the reproduction number is believed to be given by some value between 2.4 and 3.3. Estimates higher than that may be explained by a large number of imported cases before the day being considered.
- Since the estimator is based on assumptions about the infectivity of the virus, and given that the data are not perfect because of a change of reporting criteria, the amount of testing etc., the estimates should be cautiously interpreted and not be taken at face value. However, we believe one can draw qualitatively correct conclusions from them.

### References ###

[1]: Fraser, C. (2007). *Estimating Individual and Household Reproduction
Numbers in an Emerging Epidemic.* PLOS ONE 2 (8), [https://doi.org/10.1371/journal.pone.0000758](https://doi.org/10.1371/journal.pone.0000758).

##
